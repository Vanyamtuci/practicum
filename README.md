
# Командная строка команда bash
Здесь будут описаны базовые команды BASH в работе с командной строкой:
* . - это переход в текущую директорию. Но это нужно довольно редко — например, для запуска скриптов и программ, которые принимают папку в качестве параметра(пример в команде mv).
* .. - это переход в родительскую директорию.
* ~ - это переход в домашнюю директорию.
* / - это переход в корневую директорию.
* $ - компьютер ожидает команду.
pwd (print working directory) - это команда, которая выводит путь к текущей директории. Командная строка выведет путь к папке, в которой вы находитесь.<br>
Пример:
```BASH
$ pwd 
/c/Users/%USERNAME%
/Users/%USERNAME%  
```
cd (change directory) - это команда, которая меняет текущую директорию. Чтобы перейти в домашнюю директорию, необходимо ввести cd ~. ~ - это обозначение домашней директории. Чтобы перейти в корневую директорию, необходимо ввести сd ~. Чтобы перейти в любую другую нужную вам директорию, необходимо ввести cd и путь к нужной папке. После каждой директории ставить "/"(в конце не надо). Также сd может работать с символами домашней директории ~ и родительской директории .. <br>
Пример:
```BASH
$ cd Users/Documents/Document1
```
ls (list directory) - это команд, которая выводит содержимое директории. У этой команды есть флаг -a, который выводит расширенный список текущей директории. В нём отобразятся все скрытые файлы, которые начинаются с символа . (например, файлы конфигурации). В том числе два особых файла . и .., которые обозначают текущую и родительскую директории. Ls также может работать с символами домашней директории ~ и родительской директории ..<br>
Пример:
```BASH
$ ls # вывели список файлов
file.txt
photo.png

$ ls -a # вывели список, в котором отображаются скрытые файлы ., .. и .git
.
..
.git
file.txt
photo.png 
```
touch (коснуться) - это команда создания нового файла в текущей директории. Чтобы создать файл, нужно ввести в консоль команду touch с именем файла в качестве параметра: touch %ИМЯ_ФАЙЛА%. Желательно указывать расширение файла, чтобы компьютер подобрал подходящую программу.<br>
Пример:
```BASH
$ touch my-new-file.txt # создали файл my-new-file.txt 
```
mkdir (make directory - создать директорию) - это команда создания новой директории в текущей директории. Пример:
```BASH
$ mkdir new-dir # создали директорию new-dir 
```
Можно создать целую структуру директорий одной командой с помощью флага -p.<br>
Пример:
```BASH
$ mkdir -p dir1/dir-inside/dir-deeper-inside
# создали папку dir-deeper-inside в папке dir-inside, которая находится в папке dir1 
```
Также можно использовать обе команды вместе с символом домашней директории (~) или родительской директории (..). Например, команда mkdir ~/my-git-projects создаст папку my-git-projects внутри домашней директории.
cp (copy - копировать) - это команда копирования файла или папки.  В простом виде cp принимает два параметра: что копируем и куда копируем.<br>
Пример:
```BASH
$ cp что_копируем куда_копируем

$ cp index.html src/
# скопировали index.html в папку src 
```
Также можно указать несколько сразу несколько файлов.<br>
Пример:
```BASH
$ cp что_копируем что_копируем что_копируем куда_копируем

$ cp index.html style.css script.js src/
# скопировали три файла (index.html, style.css и script.js) в папку src 
```
mv (move) - это команда перемещения файлов или папки. Ее отличие от команды cp в том, что mv удаляет файл там, где он находился и создается в указанной директории. Синтаксис команды mv аналогичен синтаксису cp. После имени команды указывают список файлов и папок, которые нужно переместить, а затем — папку, в которую нужно выполнить перемещение.<br>
Пример:
```BASH
$ mv table.csv ./very-important-files # ./ - это переход в дочернюю директорию.
# сначала указываем имя файла, который хотим переместить, потом путь — куда перемещаем  
```
cat (concatenate and print -  обьединить и распечать) - это команда считывает содержимое файла и выводит на экран. Команда cat работает только с текстовыми файлами. Вывести этой командой файл другого типа (например, изображение) не получится.<br>
Пример: 
```BASH
$ cat myfile.txt # распечатали содержимое файла myfile.txt
file-content-1
file-content-2 
```
rm (remove - удалять)- это команда удаления файла. Чтобы удалить файл, нужно напечатать команду и передать ей имя файла.<br>
Пример:
```BASH
$ rm example.txt # удалили файл example.txt из текущей папки
```
Удалить папку можно командой rmdir (от англ. remove directory — «удалить директорию»). Не забудьте указать имя папки.<br>
Пример:
```BASH
$ rmdir images # команда удалит папку images из текущей директории, 
               # если папка images пуста
```
Чтобы удалить папку с файлами нужно печатать команду rm c флагом -r. Флаг -r(-r — от англ. recursive, «рекурсивный») рекурсивно удаляет все файлы в папке, пока папка не станет пустой, а затем удаляет и ее.<br>
Пример:
```BASH
$ rm -r images # удалили папку images со всем её содержимым из текущей директории
```
## Эффективная работа с командной строкой
Команды можно связать амперсанадами && для эффективности работы.<br>
Пример: 
```BASH
$ mkdir second-project && cd second-project && touch index.html style.css
# создаём папку second-project,
# переходим в папку second-project
# и создаём в ней два файла: index.html и style.css
```
У терминала есть своя память - буфер. Чтобы просмотреть предыдущие команды нужно нажать стрелку вверх ↑. Чтобы вернуться, нужно нажать стрелку вниз ↓.<br>
С помощью кнопки Tab можно искать команды, пути не зная или не дописывая полного названия.Для команд нужно написать одну букву и два раза написать Tab. Для путей и папок достаточно написать первую букву и нажать Tab. Если файлы или папки у которых одинаковые первые буквы, нужно нажать Tab еще раз и выйдет их список.

# Как работает гит от нуля до чайханы<br>

## Что такое гит и для чего он нужен?
Любой творческий процесс состоит из набора итераций. Художник рисует эскизы, фотограф делает несколько кадров, студент создаёт файлы диплом.doc, диплом_final.doc и диплом_final_final_2.doc. Каждая такая попытка имеет ценность. Она позволяет остановиться и убедиться, что работа идёт в правильном направлении.
В отличие от художников, IT-команды не используют скетчбуки. Историю их проектов хранит отдельная программа — система контроля версий (англ. Version Control System, или коротко VCS).<br>
	Система контроля версий, или VCS, — это программное обеспечение, которое помогает отслеживать изменения в программах, текстовых файлах, больших документах, веб-сайтах и так далее. Одно изменение или группу изменений в VCS называют ревизией или версией. Каждая такая ревизия содержит информацию о том, что изменилось, кто внёс изменения, когда это было и иногда комментарии к изменению. Основные функции системы контроля версий:
* хранит историю изменений в виде отдельных ревизий;
* позволяет манипулировать историей: например, менять порядок ревизий, полностью удалять версии, возвращаться назад в истории;
* помогает анализировать изменения: например, кто и когда вносит изменения, кто чаще всего вносит изменения в определённый файл и так далее.
Одним из популярных продуктов VCS является Git, о котором и пойдет речь.
## Создание гит репозитория<br>
Для создания гит репозитория потребуется создать папку с помощью команды mkdir <br> 
С командой cd мы переходим в эту папку и с командой git init создаем гит репозиторий <br>
```BASH
$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий 
```
## git status
Чтобы проверить состояние гит репозитория , нужно использовать команду git status <br>
```BASH
$ git status # cтатус гит репозитория 
```
Если коммитов еще не было, консоль выведет No commits yet <br>
  
## git add
Далее создаем файлы, версии которых мы будем контролировать с помощью команды touch или папки с командой mkdir. <br>  
Чтобы добавить файл в гит репозитории, нужно использовать команду git add. У этой команды есть флаг --all, если мы хотим зафиксировать изменения всего содержимого репозитория. <br>
Также можно использовать команду без флага с указанием изменённого файла. <br>
```BASH
$ git add test.txt # зафиксировали изменения файл test1.txt
$ git add --all    # зафиксировали изменения cодержимого гит репозитория
```
Разница между git commit и git add:  <br>
git add добавляет файл в гит репозиторий, то есть фиксирует изменения. <br>
git commit сохраняет зафиксированные изменения, которые можно отслеживать и при необходимости откатиться.  <br>

## git commit
Теперь со спокойной душой мы можем коммитить свои измененные проекты с помощью команды git commit. <br>
Использовать эту команду рекомендуется с флагом -m и сообщением о том, что исправлено что добавлено. <br>
```BASH
$ git commit -m "Исправил эту шнягу" # коммитим с комментариями!!! 
```
## git log 
Чтобы просмотреть историю коммитов, используется команда git log
```BASH
$ git log 
```
Коммиты выйдут в обратном хронологическом порядке, то есть последние коммиты окажутся сверху первыми(как в LIFO) :) <br>

## Github, или че за тяги
Github - это платформа для удаленных репозиториев, предоставляющая кайфовый графический интерфейс. <br>
Github нужен нам для командной работы над проектом. С помощью Git мы можем создавать и коммитить локальный репозиторий <br>
И отправлять этот репозиторий на удаленный сервер, чтобы коллеги по цеху увидели твой исправленный говнокод, с чем гитхуб отлично справляется. <br>
Я думаю зарегаться и создать удаленный репозиторий у вас не составит трудностей. <br>

## SSH ключ - че это? Генерируем SSH-ключи.
SSH - это сетевой протокол для обмена данными в сети. SSH протокол шифрует данные, что делает отправку безопасной:) <br>
SSH для обмена данными использует пару ключей: <br>
* Публичный -  этот ключ шифрует данные, им можно делиться с друзьями. <br>
* Приватный - этот ключ расшифровывает данные, им делиться нельзя ни с кем. <br>
Прежде чем генерировать ссш ключи, нужно просмотреть нет ли уже созданных. По умолчанию папка с ссш ключами находится в домашнем репозитории. <br>
```BASH
$ cd ~ # перешли в домашнюю директорию
```
Обычно ссш ключи находятся в директории .ssh/ <br>
```BASH
$ ls -la .ssh/ # проверили содержимое директории.
```
Если есть файлы наподобие id_ed25519.pub, id_dsa.pub, значит ключи уже созданы, а значит надо их удалить командой rm -rf. <br>
```BASH
$ rm -rf # удаляем все безвозвратно
```
Для генерации ссш ключей используется команда ssh-keygen. <br>
Короче нужно ввести это: <br>
```BASH
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```
ed25519 - это алгоритм шифрования. Если консоль выдаст ошибку, используйте другой(Пример: rsa)
```BASH
$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```
После ввода отобразится сообщение <br>
```BASH
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи. 
```
Необходимо указать место хранения ключей. По умолчанию можно выбрать домашний каталог. Надо нажать Enter. <br>
```BASH
> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 
```
Консоль запросит кодовую фразу. Решайте нужно оно вам или в пизду. Если не нужно, то Enter 2 раза. <br>
```BASH
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again] 
```
Кайф, ключи созданы! Чтобы их посмотреть, нужно использовать команду ls <br>
```BASH
$ ls -a ~/.ssh # смотрим содержимое папки ссш.
```
Есл нигде не ошиблись, то выйдет два файла: с расширением .pub и без. Файл с расширением, это публичный ключ, а без - приватный. <br>
## Привязка SSH ключей к Github. <br>
Я устал писать, сорян <br>
Вот видос: [Яндекс](https://code.s3.yandex.net/git_Basic/SSH_Screencast.mp4 "Туда нам надо") <br>

## Связка и Синхронизация Git и Github(ура) <br>
Чтобы синхронизировать локальный и удаленный репозитории, нужно перейти на страницу удаленного репозитория, выбрать тип ссш и скопировать URL, далее использовать команду git remote add. <br>
```BASH
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git # origin - это псевдониим главного удаленного репозитория.
```
Чтобы убедиться в том, что репозитории связаны, нужно использовать команду git remove -v <br>
```BASH
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 
```
Если такое вышло, то все тигр:) Кстати флажок -v позволяет показать больше информации при выводе. <br>
## Синхронизация репозиторием и наконец то блять git push. <br>
Немного теории: <br>
Коммиты хранятся в ветках. Ветка всегда начинается с одного из коммитов. В репозитории может существовать сразу несколько веток — параллельных историй изменений. Также они могут соединяться друг с другом. <br>
Самая первая ветка называется main или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него. <br>
Чтобы отправить изменения на удаленный гит репозиторий, нужно использовать команду git push. В первый раз она используется с флагом -u и с параметрами origin и названием текушей ветки(main или master) <br>
```BASH
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте  заменить main на master. 
```

Появится отладочная информация, количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее. <br>
Если вы указали кодовую фразу, то придется ее вводить раз за разом :Э <br>
Ну а дальше заходите в Github репозиторий	и там смотрите, шо синхронизировалось. <br>

## Хэш - идентификатор коммита
Когда мы выводим историю коммитов с помощью команды git log, мы встречаем в выводе commit и какая то непонятная хрень из букв и цифр. Это и есть хэш коммита. Хэширование - это способ преобразовать данный и получить их отпечаток. В хэше содержится информация по коммиту, а именно когда был сделан коммит, содержимое файлов в репозитории и ссылка на пред коммит. Git преобразует информацию в хэш алгоритмом SHA-1. Хэш это строка состоящая из цифр 0-9 и латинских букв A-F. Хэш обладает следующими свойствами:
* Хэш для одного набора данных будет одинаковым.
* Хэш для разного набора данных будет сильно отличаться.
Git хранит таблицу хэш->информация о коммите в служебной папке .git. Если известен хэш, то известна и инфа по коммиту.

## Изучаем лог
```
commit e83c5163316f89bfbde7d9ab23ca2e25604af290 --> это хэш коммита 
Author: Linus Torvalds <torvalds@linux-foundation.org> --> автор коммита, его имя и почта 
Date:   Thu Apr 7 15:13:13 2005 -0700 --> дата и время создания коммита 

Initial revision of "git", the information manager from hell --> сообщение коммита.
``` 
## HEAD - файл
Служебный файл HEAD указывает на последний коммит. Чтобы просмотреть этот файл, нужно перейти в папку .git, с помощью команды cat прочитать содержимое файла(в нем будет находиться ссылка на хэш такого вида refs/heads/master). Если прочитать ссылку командой cat, консоль выведет хэш последнего коммита.
```BASH
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка 
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты 
```

## Cтатусы файлов в Git
Основные статусы файлов:
* untracked - У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
* staged - после выполнения команды git add файл попадает в staging area. Это список файлов которые войдут в коммит. В этот момент файл находится в состоянии staged. Staging area также называют index или cache.
* tracked -  это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* modified - если файл имеет состояние tracked и изменяется, то он становится modified. Например: файл был добавлен, закоммичен, и после изменен. Если ввести команду git status, то консоль выведет modified.




# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки ```. 

```
mkdir my_project
cd my_project
git init
```
## Ссылки
Пример ссылки:<br>
[Youtube](https://www.youtube.com "Ютуб") am


                        



  